#!/usr/bin/python
import xml.etree.ElementTree as ET
import re,sys
from operator import itemgetter, attrgetter

#==================================================================================================
# md2xml.amber_read_lib
#==================================================================================================
def read(root):
    """
    read reads the topology of each molecule given in the XML file and decompose the information according to the XML structure
    lib files contain information about charges and the connectivity -> main routine for the topology
    angles and dihedrals will be generated by ForConX
    Each molecule has an own lib file -> split routine is required in the input
    The input is read in th same containers as all other md programs to use similar functions -> better overview for the user
    subroutines:
    * read_mass
    * read_bond
    * read_angle -> autogenerate angles
    * read_dihedral -> autogenerate dihedrals
    * read_frcmod -> store information about improper potentials
    """
    from ..md_xml import helpers
    
    files = []
    for i in root.findall('./input/lib'):
        files.append(i.get('file'))
    residue = {}
    charge = {}
    mass = {}
    polar = {}
    read_atoms = False
    read_connectivity = False
    autogen_angle = True
    autogen_dihedral = True
    angle    = ["AUTOGENERATE"]
    dihedral = ["AUTOGENERATE"]

    print"\n\t-------------------------------"
    print"\t 1.1 Reading residue information"
    print"\t-------------------------------"
    for file in files:
        print"\n> Reading lib file(s) ",file," ..."
        print"\t\tRESIDUE",
        molname = False
        f = open(file)
        for line in f:
            if "index array str" in line:
                molname = True
            elif "unit.atoms table" in line:
                molname = False
                read_atoms = True
                line_element = line.split('.')
                molecule =  line_element[1]
            elif "unit.atomspertinfo table" in line:
                read_atoms = False
                line_element = line.split('.')
                molecule =  line_element[1]
            elif "unit.connectivity" in line:
                read_connectivity = True
                line_element = line.split('.')
                molecule =  line_element[1]
            elif "unit.hierarchy" in line:
                read_connectivity = False
                line_element = line.split('.')
                molecule =  line_element[1]
            elif molname:
                molecule = re.sub('\"', '', line)
                molecule = re.sub('\n', '', molecule)
                molecule = re.sub(' ', '', molecule)
                # Use same syntax as in CHARMM to use the same functions
                mol_name = ""
                mol_name += molecule
                if molecule not in residue:
                    residue[molecule] = []
                    residue[molecule].append(mol_name)
                print "\t",mol_name,
            elif read_atoms:
                line_sub = re.sub('\"', '', line)
                line_sub = re.sub('\n', '', line_sub)
                ext_atom = "ATOM "
                ext_atom += line_sub
                residue[molecule].append(ext_atom)
            elif read_connectivity:
                ext_bond = "BOND "
                ext_bond += line
                residue[molecule].append(ext_bond)
        print "\n"
    f.close()

    print"\t------------------------------------"
    print"\t1.2 Read masses and polarizabilities"
    print"\t------------------------------------"
    read_mass(root,mass,polar)

    print"\t---------------------------------------------------"
    print"\t1.3 Reading topology and converting residues to XML"
    print"\t---------------------------------------------------"
    for mol in root.findall('molecule'):
        molname = mol.get('name')
        if molname is None:
            continue

        (atom,bond,angle,dihedral,improper) = decompose_residue(molname,residue)
        
#       Read atoms
        (type_atom,id_atom,iatom,ivirtual) = read_atom(root,mol,atom,mass,polar)
        print'\t\tNumber of atoms         = %5s'%iatom
        print'\t\tNumber of virtual atoms = %5s'%ivirtual

#       Bonds
        nbond = read_bond(root,mol,bond,id_atom)
        print"\t\tNumber of bonds         = %5s" %nbond

#       Angles
        nangle = read_angle(root,mol,angle)
        print"\t\tNumber of angles        = %5s" %nangle,
        if "AUTOGENERATE" in angle:
            print "(autogenerated)",
        print
#       Dihedrals
        ndihedral = read_dihedral(root,mol,dihedral)
        print"\t\tNumber of dihedrals     = %5s" %ndihedral,
        if "AUTOGENERATE" in dihedral:
            print "(autogenerated)",
        print
#       Impropers will be read at a different position due to organization in AMBER input
        print

# Read frcmod here to get information about the impropers in the force field
# Important to use the same atom ordering for the impropers in the XML

    print"\n\t-------------------------------------------------------------------------------"
    print"\t1.4 Reading inter-/intramolecular potentials"
    print"\t---------------------------------------------------------------------------------"
    helpers.write_xml(root,'forconx.xml')
    read_frcmod(root,mol,id_atom,type_atom)
    print

# TODO: Check if this routine is necessary here or if it is possible to have it separately.
#    print"\n\t----------------------------------------------"
#    print"\t1.5 Converting coordinates"
#    print"\t----------------------------------------------"
#    pointer = root.find('input/coordinates') 
#    if pointer is not None:
#        pdb = pointer.get('pdb')
#        print "\t\tCoordinate file = %s ..."%pdb
#        read_coordinates(root,moleculelist)
#    else:
#        print"\t\tNo coordinates to be converted."
    print "\n\n"
    
    return

#==================================================================================================
# md2xml.read_mass
#==================================================================================================
def read_mass(root,mass,polar):
    """
    Read the masses and if available polarizability for each atom type from the frcmod
    Each atomtype has its own charge which is defined in the lib files
    To connect the masses and polarizabilities with the molecule, both files have to be read
    This routine uses the keyword "BOND" to recognize that all atomtypes are read
    -> Maybe, we want to improve this condition. Up to know I have no better idea

    """
    from ..md_xml import helpers
    
    try:
        frcmodfile=root.find('./input/frcmod').get('file')
    except IOError:
        helpers.error("frcmod file is missing")
    except:
        helpers.error("frcmod is ill-defined")
    print"> Read masses from frcmod file ",frcmodfile," ..."
    f=open(frcmodfile)

#   reading mass statements
    name = {}
    molname = False

    for line in f:
        if line.strip():
            # The keyword in the frcmod are used according to the AMBER manual - Keywords are 4 characters long
            if 'MASS' in line:        
                molname = True
            elif 'BOND' in line:
                molname = False
            elif molname:
                if len(line.split())>2:
                    atomname, mass_at, pol = line.split()
                    polar[atomname] = float(line2[2])
                else:
                    atomname, mass_at = line.split()
                mass[atomname] = float(mass_at)
    f.close()
    # The following statements should be piped into the log file
    for imass in sorted(mass, key=mass.get):
        print"\t\tMASS %-4s %-8.3f" %(imass, mass[imass])
    print
    return mass,polar

#==================================================================================================
# md2xml.decompose_residue
#==================================================================================================
def decompose_residue(molname,residue):
    """
    Generate hashes to atom, bond, angle, dihedral and improper information
    Decompose the residue container into entries for bonds, angles, etc. according to the keywords
    given by the AMBER manual
    """
    atom     = []
    bond     = []
    angle    = []
    dihedral = []
    improper = []
    # angle and dihedral information for each molecule are generated automatically via Leap in a
    # preprocessing step for AMBER -> we generate the angle and dihedral for each molecule
    # based on the given connectivities
    angle.append("AUTOGENERATE")
    dihedral.append("AUTOGENERATE")

    #   Decompose residue information into atom, bond, angle, 
    #   dihedral and improper 
    print'\t<molecule name="%s">'%molname
    for line in residue[molname]:
        if line[0:4]=="ATOM":
            atom.append(line)
            
        if line[0:4]=="BOND":
            bond.append(line)

        if line[0:4]=="ANGL":
            angle.append(line)

        if line[0:4]=="DIHE":
            dihedral.append(line)
            
        if line[0:4]=="IMPR":
            improper.append(line)
    return atom,bond,angle,dihedral,improper

#==================================================================================================
# md2xml.read_atom
#==================================================================================================
def read_atom(root,mol,atom,mass,pol):
    """
    reading ATOM from frcmod
    This procedure combine all information from lib files (charge) and frcmod for each atomtype

    Virtual atoms are detected by their non-existing mass.

    """
    from ..md_xml import molecule
    from ..md_xml import input_output
    from ..md_xml import helpers

    type_atom = {}
    id_atom   = {}
    iatom     = 0
    ivirtual  = 0
    id_index  = 0
    for line in atom:
        id_index += 1
        line_element        = line.split()
        atomname            = line_element[1]
        atomtype            = line_element[2]
        charge              = float(line_element[8])
        type_atom[atomname] = line_element[2]
        id_atom[atomname]   = str(id_index)
        
        if mass[atomtype]>0.1:
            iatom += 1
            current_atom = molecule.atomClass(mol,atomname)
            current_atom.mass = mass[atomtype]
        else:
            ivirtual += 1
            current_atom = molecule.virtualClass(mol,atomname)
        current_atom.type = atomtype
        current_atom.charge = charge
        # Polarization if defined in the frcmod file and will be handled comparable with the masses
        if len(pol) >0:
            if line_element[2] in pol:
                current_atom.alpha = abs(float(pol[atomtype]))
            else:
                helpers.error('Please define the polarizability for atom type %s!'%line_element[2])
    return type_atom,id_atom,iatom,ivirtual

#==================================================================================================
# md2xml.read_bond
#==================================================================================================
def read_bond(root,mol,bond,id_atom):
    """
    reading BOND from lib file
    Lib files provide the bond information in a integer format -> this routine converts this integer
    format to atomnames to improve readability in the XML file
    This routine also adds the bonds to the relevant molecule via atomnames and to the force field
    via atomtypes to assign later force constant and bond length
    """
    from ..md_xml import molecule
    from ..md_xml import bonds
    from ..md_xml import helpers

    ibond = 0
    for line in bond:
        line = line.split()
        del line[0]
        bond0 = -1
        for i in id_atom:
            if str(line[0]) == id_atom[i]:
                bond0 = i
        for i in id_atom:
            if str(line[1]) == id_atom[i]:
                bond1 = i
        if bond0 < 0:
            helpers.error('Please check your input files- Error while reading bonds!')
        atomnames = bonds.sequence(' '.join([bond0,bond1]))
        atom_i = molecule.atomClass(mol,bond0)
        atom_j = molecule.atomClass(mol,bond1)
        type_i = atom_i.type
        type_j = atom_j.type
        atomtypes = bonds.sequence(' '.join([type_i,type_j]))
        current_bond = molecule.bondClass(mol,atomnames)
        current_bond.type = atomtypes
        bonds.harmClass(root,atomtypes)
        ibond += 1
    return ibond

#==================================================================================================
# md2xml.read_angle
#==================================================================================================
def read_angle(root,mol,angle):
    """
    Autogenerate angles by ForConX to complete the information about the molecule topology
    """
    from ..md_xml import molecule
    from ..md_xml import angles

    iangle = 0
    current_molecule = molecule.moleculeElement(mol,mol.get('name'))
    for atomnames in current_molecule.generate_angle():
        atoms = atomnames.split()
        atom_i = molecule.atomClass(mol,atoms[0])
        atom_j = molecule.atomClass(mol,atoms[1])
        atom_k = molecule.atomClass(mol,atoms[2])
        atomtypes = angles.sequence(' '.join([atom_i.type,atom_j.type,atom_k.type]))
        current_angle = molecule.angleClass(mol,atomnames)
        current_angle.type = atomtypes
        angles.harmClass(root,atomtypes)
        iangle  += 1
    return iangle

#==================================================================================================
# md2xml.read_dihedral
#==================================================================================================
def read_dihedral(root,mol,dihedral):
    """
    dihedrals must also be generated
    This procedure works in the same way as the angle function
    """
    from ..md_xml import molecule
    from ..md_xml import dihedrals

    idihedral = 0
    current_molecule = molecule.moleculeElement(mol,mol.get('name'))
    
    if "AUTOGENERATE" in dihedral[0]:
#       Constructing all possible dihedrals     
        for atomnames in current_molecule.generate_dihedral():
            atoms = atomnames.split()
            atom_i = molecule.atomClass(mol,atoms[0])
            atom_j = molecule.atomClass(mol,atoms[1])
            atom_k = molecule.atomClass(mol,atoms[2])
            atom_l = molecule.atomClass(mol,atoms[3])
            atomtypes = dihedrals.sequence(' '.join([atom_i.type,atom_j.type,atom_k.type,atom_l.type]))
            current_dihedral = molecule.dihedralClass(mol,atomnames)
            current_dihedral.type = atomtypes
            dihedrals.cosClass(root,atomtypes)
            idihedral += 1
        return idihedral

#==================================================================================================
# md2xml.read_frcmod
#==================================================================================================
# Additional variables to root are necessary for generating the impropers per molecule
def read_frcmod(root,mol,id_atom,type_atom):
    """
    Amber supports the following potentials
    Bond : k_b (b-b_0)^2
    Angle : k_theta (theta - theta_0)^2 
    Dihedral/ Improper : K_n/2 * (1 + cos(n*phi - delta) )
    Non-bonded : Lennard-Jones and Coulomb
    This routine assign force constants and equilibrium distances, angles, etc.
    This routine has the following subroutines:
    - find_parameter_bonds
    - find_parameter_angles
    - find_parameter_dihedrals
    - find_parameter_impropers
    - find_parameter_nonbonded

    """
    from ..md_xml import bonds
    from ..md_xml import angles
    from ..md_xml import dihedrals
    from ..md_xml import impropers
    from ..md_xml import nonbonded
    from ..md_xml import helpers
    
    frcmodfile=root.find('./input/frcmod').get('file')    
    print "> Reading frcmod file ",frcmodfile," ..."
    f=open(frcmodfile)

    name = {}
    parameter = {}
    parameter["BONDS"] = []
    parameter["ANGLES"] = []
    parameter["DIHEDRALS"] = []
    parameter["IMPROPERS"] = []
    parameter["NONBONDED"] = []
    parameter["DUMP"] = []
    key = "DUMP"
    
    molname = False
    read_bonds = False
    read_angles = False
    read_dihe = False
    read_impr = False
    read_vdw = False
    next(f) #  skip comment line of frcmod file
    for line in f:
        if line.strip():
            if 'MASS' in line: # mass will be read during reading lib files to store information together
                read_dummy = True
            elif 'BOND' in line:
                read_bonds = True
                read_dummy = False
            elif 'ANGL' in line:
                read_bonds = False
                read_angles = True
            elif 'DIHE' in line:
                read_angles = False
                read_dihe = True
            elif 'IMPR' in line:
                read_impr = True
                read_dihe = False
            elif 'NONB' in line:
                read_vdw = True
                read_impr = False
            elif read_dummy: # only dummy to take care of all key words
                pass
            elif read_bonds:
                line2 = re.sub("[-\n]",' ',line)
                parameter["BONDS"].append(line2)
            elif read_angles:
                line2 = re.sub("[-\n]",' ',line)
                parameter["ANGLES"].append(line2)
            elif read_dihe:
                line2 = re.sub("[-\n]",' ',line)
                parameter["DIHEDRALS"].append(line2)
            elif read_impr:
                line2 = re.sub("[-\n]",' ',line)
                parameter["IMPROPERS"].append(line2)
            elif read_vdw:
                line2 = re.sub("[-\n]",' ',line)
                parameter["NONBONDED"].append(line2)
            else:
                helpers.error('Missing keywords in frcmod.')

#   Assigning force constants and equilibrium values
    print"\n\t----------------------------------------------------------------------------------"
    print"\t1.5.1 Assigning force constants and equilibrium values of bond and angle potentials"
    print"\t----------------------------------------------------------------------------------"

    ibonds      = find_parameter_bonds(root,parameter["BONDS"])
    print"\t\tNumber of bond potentials       = %6s" % (ibonds)

    iangles     = find_parameter_angles(root,parameter["ANGLES"])
    print"\t\tNumber of angles potentials     = %6s" % (iangles)
    
    print"\n\t---------------------------------------------------------"
    print"\t1.5.2 Nonbonded Interactions"
    print"\t---------------------------------------------------------"
    ivdw=find_parameter_nonbonded(root,parameter["NONBONDED"])
    print"\t\tNumber of atomtypes   = %6s" % (ivdw)
    print

    # The nonbonded interactions are read in front of the dihedral since special 1-4 scaling factors are defined in the dihedral section
    
    print"\n\t----------------------------------------------------------------------------------"
    print"\t1.5.3 Assigning force constants and equilibrium values of dihedrals and impropers potentials"
    print"\t----------------------------------------------------------------------------------"

    idihedrals  = find_parameter_dihedrals(root,parameter["DIHEDRALS"])
    print"\t\tNumber of dihedral potentials   = %6s" % (idihedrals)

    # read improper parameters - based on them the impropers for the molecule are found
    iimpropers  = find_parameter_impropers(root,parameter["IMPROPERS"])
    print"\t\tNumber of improper potentials   = %6s" % (iimpropers)
        
    f.close()
    return

#==================================================================================================
# md2xml.find_parameter_bonds
#==================================================================================================
def find_parameter_bonds(root,parameter):
    """
    compare XML structure with parameter bond section 
    adding respective force constants and equilibrium distances

    """
    from ..md_xml import bonds
    ibonds = 0

    current_bonds = bonds.bondsElement(root)
    for bond_xml in current_bonds.list("HARM"):
        for line in parameter:
            line_element = line.split()
            type = bonds.sequence(' '.join(line_element[0:2]))
            hit  = match_type(type.split(),bond_xml.split())
            
            if hit:
                harm = bonds.harmClass(root,bond_xml)
                harm.k = float(line_element[2])
                harm.r0 = float(line_element[3])
                ibonds += 1
    return ibonds

#==================================================================================================
# md2xml.find_parameter_angles
#==================================================================================================
def find_parameter_angles(root,parameter):
    """
    compare XML structure with parameter angle section 
    adding respective force constants and angles

    """
    from ..md_xml import angles
    iangles = 0

    current_angles = angles.anglesElement(root)
    for angle_xml in current_angles.list("HARM"):
        for line in parameter:
            line_element = line.split()
            type = angles.sequence(' '.join(line_element[0:3]))
            hit = match_type(type.split(),angle_xml.split())
            if hit:
                harm = angles.harmClass(root,angle_xml)
                harm.k = float(line_element[3])
                harm.theta0 = float(line_element[4])
                iangles += 1
    return iangles

#==================================================================================================
# md2xml.find_parameter_dihedrals
#==================================================================================================
def find_parameter_dihedrals(root,parameter):
    """
    compare XML structure with parameter dihedral section 
    adding respective force constants and cosine values

    """
    from ..md_xml import molecule
    from ..md_xml import dihedrals
    from ..md_xml import nonbonded
    import numpy
    
    idihedrals = 0
    current_dihedrals = dihedrals.dihedralsElement(root)

    elec14 = {}
    vdw14  = {}
    for dihedral_xml in current_dihedrals.list("COS"):
        for line in parameter:
            line_element = line.split()
            type = dihedrals.sequence(' '.join(line_element[0:4]))

            hit1 = match_type(type.split(), dihedral_xml.split())
            hit2 = match_type((type.split())[::-1], dihedral_xml.split())
            if hit1 or hit2:
                cos = dihedrals.cosClass(root,dihedral_xml)
                k = float(line_element[5])
                n = abs(float(line_element[7]))
                delta = float(line_element[6])
                
                old_n = cos.n
                old_k = cos.k
                old_delta = cos.delta
                if "X" in line_element[0:4] and old_n is not None:
                    continue
                current_k = float(line_element[5])
                current_n = float(line_element[7])
                current_delta = float(line_element[6])
                if current_n in old_n:
                    continue
                else:
                    cos.n = old_n + [current_n]
                    cos.k = old_k + [current_k]
                    cos.delta = old_delta + [current_delta]
                idihedrals += 1
                
#               1-4 scaling factors defined by the dihedrals
                if (len(line_element) > 7):
                    atom_1 = line_element[0]
                    atom_4 = line_element[3]
                    if atom_1 not in elec14.keys():
                        elec14[atom_1] = []
                    if atom_4 not in elec14.keys():
                        elec14[atom_4] = []
                    if atom_1 not in vdw14.keys():
                        vdw14[atom_1] = []
                    if atom_4 not in vdw14.keys():
                        vdw14[atom_4] = []

                    for i in range(8,10):
                        tmp  = line_element[i].split("=")
                        factor = 1.00/float(tmp[1])
                        if "SCEE" in line_element[i]:
                            elec14[atom_1].append(factor)
                            elec14[atom_4].append(factor)
                        if "SCNB" in line_element[i]:
                            vdw14[atom_1].append(factor)
                            vdw14[atom_4].append(factor)
                            
    current_nonbonded = nonbonded.nonbondedElement(root)
    for i in elec14.keys():
        atom = nonbonded.atomClass(root,i)
        atom.elec14 = numpy.mean(elec14[i])
    for i in vdw14.keys():
        atom = nonbonded.atomClass(root,i)
        atom.vdw14 = numpy.mean(vdw14[i])
    return idihedrals    

#==================================================================================================
# md2xml.find_parameter_impropers
#==================================================================================================
def find_parameter_impropers(root,parameter):
    """
    compare XML structure with parameter improper section 
    adding respective force constants and cosine values

    """
    from ..md_xml import molecule
    from ..md_xml import impropers
    from ..md_xml import helpers

    # <impropers>    
    current_impropers = impropers.impropersElement(root)
    improper_list = []
    for line in parameter:
        line_element = line.split()
        type = impropers.sequence(' '.join([line_element[2],
                                            line_element[0],
                                            line_element[1],
                                            line_element[3]]))
        improper_list.append(type)
        cos = impropers.cosClass(root,type)
        cos.k = [float(line_element[5])]
        cos.n = [float(line_element[7])]
        cos.delta = [float(line_element[6])]
        
    # <molecule/improper>
    iimpropers = 0
    for mol in root.findall('molecule'):
        current_molecule  = molecule.moleculeElement(mol,mol.get('name'))
        for i in current_molecule.generate_improper():
            name = i.split()
            atom_i = molecule.atomClass(mol,name[0])
            atom_j = molecule.atomClass(mol,name[1])
            atom_k = molecule.atomClass(mol,name[2])
            atom_l = molecule.atomClass(mol,name[3])
            type_i = atom_i.type
            type_j = atom_j.type
            type_k = atom_k.type
            type_l = atom_l.type
            
            for line in improper_list:
                if line == ' '.join([type_i,type_j,type_k,type_l]):
                    current_improper = molecule.improperClass(mol,i)
                    current_improper.type = ' '.join([type_i,type_j,type_k,type_l])
                    current_improper.central = name[0]
                    iimpropers += 1
    return iimpropers

#==================================================================================================
# md2xml.find_parameter_nonbonded
#==================================================================================================
def find_parameter_nonbonded(root,parameter):
    """
    generates nonbonded parameters.
    Since rmin/2 is stored in frcmod, sigma is gained by multiplying 2^(5/6)=1.781797
    """
    from ..md_xml import molecule
    from ..md_xml import nonbonded

    # Generating typelist    
    inb = 0
    typelist = []
    for i in root.findall("molecule/atom"):
        typelist.append(i.get("type"))

    for type_i in sorted(set(typelist)):
        nb_i = nonbonded.atomClass(root,type_i)
        for line in parameter:
            line_element = line.split()
            if line_element[0] == type_i:
                nb_i.epsilon = float(line_element[2])
                nb_i.sigma   = float(line_element[1])*1.781797
        inb += 1
    return inb

#==================================================================================================
# amber.shrink_atomtypes
#==================================================================================================
def shrink_atomtypes(root):
    import molecule
    import bonds
    import angles
    import dihedrals
    import impropers
    import nonbonded
    """
    AMBER uses a two letter code for atomtypes. Therefore, it may be 
    necessary to reduce existing atomtypes in forconx.xml.

    This shrinking routine keeps the first letter of the atomtype since this indicates 
    (at least to some extent) the chemical element. The second letter of the atomtype
    is changed such as all names of atomtypes differ. 
    """
    
    secondletter = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    print "\tShrinking atomtypes in xml if necessary ..."
    oldtypes = []
    for i in root.findall('./molecule/atom'):
            type_i = i.type
            oldtypes.append(type_i)

    oldtypes = sorted(set(oldtypes))
    newtypes = []
    for i in oldtypes:
        print i 
        index = 0
        ambertype = i[0:2]
        while ambertype in newtypes:
            tmp = list(ambertype)
            tmp[1] = secondletter[index]
            index += 1
            if index > len(secondletter):
                print "Shrinking of ",i," is not possible."
                sys.exit()
            ambertype=''.join(tmp)
        newtypes.append(ambertype)
        print "\t\t",i,"-->",ambertype
    print    

    #   ./molecules/atom
    for iatom in root.findall('./molecule/atom'): 
        i = oldtypes.index(iatom.type)
        #       Look for the index of the atomtype of atom in oldtypes
        #       and replace this atomtype by the corresponding newtype
        iatom.type = newtypes[i]

#   ./bonds
    bondlist = root.findall('./bonds/*')
    for bond in bondlist:
        bondtypes = bond.type.split()
        i1 = oldtypes.index(bondtypes[0])
        i2 = oldtypes.index(bondtypes[1])
#       resort indices
        type_bond = ''.join([newtypes[i1]," ",newtypes[i2]])
        type_bond = bonds.sort(type_bond)
        bond.type = type_bond
        
#   ./angles
    anglelist = root.findall('./angles/*')
    for angle in anglelist:
        angletypes = angle.type.split()
        i1 = oldtypes.index(angletypes[0])
        i2 = oldtypes.index(angletypes[1])
        i3 = oldtypes.index(angletypes[2])
        #       resort indices
        type_angle = ''.join([newtypes[i1]," ",newtypes[i2]," ",newtypes[i3]])
        type_angle = angles.sort(type_angle)
        angle.type = type_angle

#   ./dihedrals
    dihedrallist = root.findall('./dihedrals/*')
    for dihedral in dihedrallist:
        dihedraltypes = dihedral.type.split()
        i1 = oldtypes.index(dihedraltypes[0])
        i2 = oldtypes.index(dihedraltypes[1])
        i3 = oldtypes.index(dihedraltypes[2])
        i4 = oldtypes.index(dihedraltypes[3])
#       resort indices
        type_dihedral = ''.join([newtypes[i1]," ",newtypes[i2]," ",newtypes[i3]," ",newtypes[i4]])
        type_dihedral = dihedrals.sort(type_dihedral)
        dihedral.type = type_dihedral
         
#   ./impropers
    improperlist = root.findall('./impropers/*')
    for improper in improperlist:
        impropertypes = improper.type.split()
        i1 = oldtypes.index(impropertypes[0])
        i2 = oldtypes.index(impropertypes[1])
        i3 = oldtypes.index(impropertypes[2])
        i4 = oldtypes.index(impropertypes[3])
#       resort indices
        type_improper = ''.join([newtypes[i1]," ",newtypes[i2]," ",newtypes[i3]," ",newtypes[i4]])
#        type_improper = impropers.sort(type_improper)
#       not active at the moment
        improper.type = type_improper

#   ./nonbonded
    nonbondedlist = root.findall('./nonbonded/atom')
    
    for nonbonded in nonbondedlist:
        i1 = oldtypes.index(nonbonded.type)
        print nonbonded.type
        nonbonded.type = newtypes[i1]

    nonbondedlist_vdw = root.findall('./nonbonded/vdw')
    
    for nonbonded in nonbondedlist_vdw:
        nonbondedtypes = nonbonded.type.split()
        i1 = oldtypes.index(nonbondedtypes[0])
        i2 = oldtypes.index(nonbondedtypes[1])
        type_nonbonded = ''.join([newtypes[i1], " ",newtypes[i2]])
        nonbonded.type = type_nonbonded
    print     
    return

#==================================================================================================
# amber.shrink_atomnames
#==================================================================================================
def shrink_atomnames(root):
    import molecule
    import bonds
    import angles
    import dihedrals
    import impropers
    import nonbonded
    """
    AMBER uses a two letter code for atomnames. Therefore, it may be 
    necessary to reduce existing atomnames in forconx.xml.

    This shrinking routine keeps the first letter of the atomname since this indicates 
    (at least to some extent) the chemical element. The second letter of the atomname
    is changed such as all names of atomtypes differ. 
    """
    
    secondletter = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    print "\tShrinking atomnames in xml if necessary ..."
    oldnames = []
    for i in root.findall('./molecule/atom'):
            name_i = i.name
            print name_i
            oldnames.append(name_i)

    oldnames = sorted(set(oldnames))
    newnames = []
    for i in oldnames:
        print i 
        index = 0
        ambername = i[0:2]
        while ambername in newnames:
            tmp = list(ambername)
            tmp[1] = secondletter[index]
            index += 1
            if index > len(secondletter):
                print "Shrinking of ",i," is not possible."
                sys.exit()
            ambername=''.join(tmp)
        newnames.append(ambername)
        print "\t\t",i,"-->",ambername
    print    

    
    #   ./molecules/atom
    for iatom in root.findall('./molecule/atom'): 
        i = oldnames.index(iatom.name)
        #       Look for the index of the atomtype of atom in oldtypes
        #       and replace this atomtype by the corresponding newtype
        iatom.name = newnames[i]
#        print newnames[i]


    for ibond in root.findall('./molecule/bond'): 
        bondtypes = ibond.name.split()
        i1 = oldnames.index(bondtypes[0])
        i2 = oldnames.index(bondtypes[1])
        #       Look for the index of the atomtype of atom in oldtypes
        #       and replace this atomtype by the corresponding newtype
        bond_type = ''.join([newnames[i1],' ', newnames[i2]])
        ibond.name = bond_type

    for iangle in root.findall('./molecule/angle'): 
        angletypes = iangle.name.split()
        i1 = oldnames.index(angletypes[0])
        i2 = oldnames.index(angletypes[1])
        i3 = oldnames.index(angletypes[2])
       #       Look for the index of the atomtype of atom in oldtypes
        #       and replace this atomtype by the corresponding newtype
        angle_type = ''.join([newnames[i1],' ', newnames[i2], ' ', newnames[i3]])
        iangle.name = angle_type
       
    for idih in root.findall('./molecule/dihedral'): 
        dihtypes = idih.name.split()
        i1 = oldnames.index(dihtypes[0])
        i2 = oldnames.index(dihtypes[1])
        i3 = oldnames.index(dihtypes[2])
        i4 = oldnames.index(dihtypes[3])
        #       Look for the index of the atomtype of atom in oldtypes
        #       and replace this atomtype by the corresponding newtype
        dih_type = ''.join([newnames[i1],' ', newnames[i2], ' ', newnames[i3], ' ', newnames[i4]])
        idih.name = dih_type

    for iimp in root.findall('./molecule/improper'): 
        imptypes = iimp.name.split()
        print imptypes
        print oldnames
        i1 = oldnames.index(imptypes[0])
        i2 = oldnames.index(imptypes[1])
        i3 = oldnames.index(imptypes[2])
        i4 = oldnames.index(imptypes[3])
        #       Look for the index of the atomtype of atom in oldtypes
        #       and replace this atomtype by the corresponding newtype
        imp_type = ''.join([newnames[i1],' ', newnames[i2], ' ', newnames[i3], ' ', newnames[i4]])
        iimp.name = imp_type
        
    print
    return

#==================================================================================================
# amber.shrink_moleculename
#==================================================================================================
def shrink_moleculename(root):
    import molecule
    """
    AMBER uses a three letter code for moleculenames. Therefore, it may be 
    necessary to reduce existing moleculenames in forconx.xml.

    This shrinking routine uses the first three letters of the molecule name.
    """

    for molecule in root.findall('molecule'):
        name = molecule.name
        new_moleculename = name[0:3]
        molecule.name = new_moleculename

#======================================================================================
# md2xml.match_type
#======================================================================================
def match_type(type_ff,type_xml):
    """
    This routine checks if current xml type of a bond, angle, dihedral or improper
    coincides with one of the force field.
    """
    hit = type_ff.count('X') 
    for i in range(len(type_ff)):
        if type_ff[i] == type_xml[i]:
            hit +=1
    return hit==len(type_ff)
